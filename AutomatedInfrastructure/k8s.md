# Kubernetes
## k8sを使うと何が嬉しいの？
### コンテナ運用で考えるべき様々な課題を一度に解決できる
例えば...
* 複数のKubernetes Nodeの管理
* ロールベースアクセス制御（RBAC）
* コンテナのスケジューリング
* ローリングアップデート
* スケーリング/オートスケーリング
* コンテナの死活監視
* サービスディスカバリ（サービスとIPを紐付ける機構のこと。これによりコンテナの作成・削除に伴ってIPが変わっても通信が可能となる。）
* ロードバランシング
* データの管理
* ワークロードの管理（アプリケーションの実行方法的なこと、ステートレス、ステートフル、バッチジョブ、デーモン...）
* ログの管理
* Infrastructure as Code
* その他エコシステムとの連携や拡張

### Infrastructure as Code
* k8sではYAML形式やJSON形式で記述した宣言的なコード（マニフェスト）によって、デプロイするコンテナや周辺リソースを管理することができる。(= Infrastructure as Code)
* マニフェストは、木（ツリー）構造で表現できるデータであり、例えばコマンドラインツール「kubectl」ではYAML形式で記述されたマニフェストを元にリソースの作成や削除、変更といった操作を行える。
* マニフェストで定義した内容で処理できる内容一例
```bash
# マニフェストファイルによるリソースの作成
$ kubectl apply -f <manifest file>
```

   1. 設定に応じてコンテナを作成するクラスタノードを決定する
   2. そのクラスタノード上にコンテナ作成のためのイメージファイルをダウンロードする
   3. コンテナを作成しIPアドレスやストレージなどのリソースを割り当てる
   4. コンテナ内で指定されたプログラムを実行する

```bash
# ※マニフェストファイルが元となったリソースの削除
$ kubectl delete -f <manifest file>
```

* CloudFormationやOpenStackHeatに似てる

### スケーリング/オートスケーリング
* k8sはコンテナクラスタを形成して、複数のNodeを管理する
* 同じイメージを元とするレプリカのコンテナをデプロイすることで負荷分散や耐障害性の確保やレプリカ数のコントロールによって、オートスケーリングができる

### スケジューリング
* 

## 概要
Kubernetesは、複数台のコンピュータをネットワークで接続した「クラスタ環境」を使い、「ノード」と呼ばれるクラスタ内のコンピュータ上で実行されるサーバーソフトウェアを管理するツール
コンテナ技術によって、ハードウェアやOS/カーネルの性能や種類が異なるものを混在させることができるので実行環境がハードやOSに依存しないように構成できる。

## アーキテクチャ
全てのKubernetesクラスタには2種類のノード（マシン）がある。（= マスターとワーカー）
ワーカーでのペイロード（アプリ）の実行において、マスターはクラスターを制御および監視する。
### マスターの構成要素
* etcd: kubernetesオブジェクト、それ自身の状態、アクセス情報、クラスタの構成情報に関する全データを保持するデータベース
* API Server: クラスタを操作するためのエンドポイントを持つRESTfulAPIサーバー。マスターノードとワーカーノードのほぼ全てのコンポーネントへの実行命令はこのサーバーを介して行われる
* Scheduler: どのペイロードをどのマシンで実行すべきかを決定する責任を負う。新しいPod要求を受け付けるために、API Serverを監視する。Nodeと通信して新しいPodを作成し、リソースを割り当てたり成約を課しながらNodeにタスクを割り当てる。
* Control Manager: クラスタの状態を監視、期待される状態をもたらすためのアクションを実行する制御ループ

### ワーカーノードの構成要素
* kubelet: マスターノードのAPIサーバーと通信し、ワーカーノード要にスケジュールされたコンテナを実行する。
   * Nodeをクラスタに登録し、Schedulerからのタスク割り当てを監視し、新しいPodをインスタンス化し、Masterに報告する。
* kube Proxy: アプリユーザーのリクエストをIPテーブル/IPVSを使用して、適切なPodに転送する。
   * IPテーブル: NATテーブルのこと？？ネットワークのアドレス変換実施において、グローバルIPアドレスとプライベートIPアドレスを変換するために1対1で紐付けて管理するテーブル
   * IPVS: Linuxでロードバランサを構築するためのソフトウェアLinux kernel内部に実装されている。基本的にL4までの情報を見てパケットをリアルサーバーに転送する。
* Pod: 全てのコンテナを実行する。ポットで抽象化せずにコンテナを実行することはできない。ポッドはk8sにおけるコンテナ間のネットワークに不可欠な機能を追加する。また、各ポッドには`kube-proxy`がトラフィックをルーティングするために使用する独自のIPアドレスが割り当てられる。このIPアドレスはクラスター内でのみ見える。ポッド内でマウントされたボリュームは全てのコンテナからも見ることができ、これらのボリュームは、ポッド間での非同期的な連携に使われたりする。

### コントローラー
何らかの方法でポッドを制御するオブジェクト
#### レプリカセット（ReplicaSet）
* 特定のポッドのレプリカを作成する。
* ポッドがなんらかの理由で停止した場合に通知を受けて、レプリカをつくる。
#### デプロイメント（Deployment）
* レプリカをかんりするためにレプリカセットを使用するより高次のオブジェクト。新規のReplicaSetはスケールアップさせ、既存のReplicaSetはスケールダウン（最終的に削除）させることで、ローリングアップグレードを提供する。
#### サービス（Service）
* ポッドにデータパケットを配信する。
* 「パケット」を対応するノードに配布する際にロードバランサとして機能することを主な役割とするコントローラーオブジェクト
* ワーカーノード全体で同様のポッド（ポッドラベルで識別）をグループ化するコントローラー構造

#### イングレス（Ingress）
* 全てのパケットがクラスターへ流れる際に通過するフローティングプラットフォーム
* イングレスコントローラーは外の世界とクラスター内で実行されている全てのサービスとが通信を行うための単一の接点。
* セキュリティポリシーの設定、監視、及び単一の場所でのロギングも簡単に行えるようになる。


## 用語
### クラスタ
クラスタ内では、複数サーバーがネットワーク上に構成されており、各サーバー上で、プログラムが動作する。
設定に応じてサーバー上でプログラムを起動したり、プログラムへのコネクションを管理する

## 代表的なリソースオブジェクト
| 名称 | 説明 |
| --- | --- |
| Pod | 使用するコンテナや実行するプログラムを定義 |
| Deployment | Podの管理方法を定義 |
| Job | 非定常的に処理を実行するジョブを定義 |
| CronJob | 定期的に実行されるジョブを定義する |
| Service | ネットワークサービスを定義 |
| ConfigMap | コンテナで使用される各種設定リソースを定義 |
| Secret | コンテナで使用される各種設定リソースを定義 |
| Volume | コンテナに割り当てるストレージを定義する |
| NameSpace  | 管理のための名前空間を定義 |

## デプロイの流れ：
DevOps -> API Server -> Scheduler -> Cluster ->Nodes -> Kubelet -> Container Engine -> Pod内にコンテナ作成

## アプリユーザーのリクエストの流れ：
App user -> Kube proxy -> Pod -> Container(ここでアプリが動きます)