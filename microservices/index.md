* マイクロサービスとは、WebAPIなどのRPC（Remote Procedure Call）を通じて、小さいサービス同士をつないで連携し、一つのサービスを構成する手法のこと。
* 基本的な思想
   * サービスを孤高製する各要素を疎結合に構成して連携する
   * 各要素に適した技術を用いる
   * サービス感の会話はAPIなど決められた様式に従う
-> 大規模なサービスを分割して小さなコンポーネントにする設計（SOAなどの形でもともと存在していた）

* メリット
   * 障害発生時の影響を少なくし、分業して開発にあたることができる
   * 開発担当者の責任範囲を分割できること
* デメリット
   * 自分の管轄外のコンポーネントやプロダクトに対して無関心になりがちで、属人性も高っくなる

* コンポーネント単位で責任範囲が分割された世界でコミュニケーションをどうとるか
   * IDLを用いてAPIを提示する(例 Thrift)
      * IDLってなんだろう
   * テストコードをきちんと書く

* 分割と共有
   * 分割の単位をどう決めるか
      * いざ障害が発生した時に、止めて良いサービスとそうでないサービスを考えた上で設計する
      * 分割の最小単位を、ユーザーにとって動いてほしい単位の一つの1個にマイクロサービスがある状態にすると良い
      * ユーザーから見たら同じ機能だが、提供プラットフォームが違うものは分ける

   * 共有化したい部分はどこにあるかを明確にする
      * 例えばDBやストレージにアクセスするための特殊なビジネスロジックは1個のコンポーネントにまとめた方がメンテナンスがしやすく、再利用性が高まる

* マイクロサービスアーキテクチャ運用の注意点
   * Cascading Failure（ドミノ倒し）
      * いわゆるドミノ倒しのように、一つのコンポーネントの障害を引き金に複数の機能が連鎖して動かなくなってしまう状態
      * サーキットブレーカー（遮断器）が必要（機能Aが壊れた時にも機能Bが動き続けるような考慮）
      -> サービスの本質的な部分を使えるようにし、障害が起こっている部分へのアクセスを一時的に切り離す
      * 他にも多少データが古くても動いて問題ナイものならデータキャッシュし、ほしい応答が得られない時に代わりに応答するやり方もある
      * Draceful Degradation: サービス全体の品質を積極的に低下させることで、サービスの本当に大事な部分を守る
   * Cyclic Dependency（循環依存）
      * マイクロサービスが巡り巡って自分自身に依存、デッドロック発生
      * 同期的な処理を行う場合にCyclic Dependencyの一箇所で利そす不足や問題が発生すると全体の処理が止まってしまう
      * Cyclic Dependencyがるようなモジュールを全て再起動させる必要があるケースえどの順番で立ち上がればいいかわからないようなケース
      * 同期的な依存を非同期化することで解決、「機能Aが情報をキューに入れ、終わりにして次の処理に映る」（例 Apache Kafka）
   * リソース不足
      * 大量の呼び出しが発生した場合に、過負荷に陥らないような考慮が必要
      * Retry Strategy, Rate Limit & Throttling（= 流量制限）
      * 例えば、機能Aがあるユーザーから受け付けるリクエストは同時に3つまで、機能Bで10件の処理待ちが発生したらそれ以上は機能Aからの呼び出しを受け付けないといった要領
   * 全体像が把握できなくなってしまう
      * 「ボタンを押す」のようなアクションを起こしたあと、どのコンポーネントが呼び出されているかを可視化するようなツールが必要
      * 分散されたサービスナイのリクエストを可視化し、システムの挙動や性能を把握することを、分散トレーシングと呼ぶ
      * ZipkinやOpenTracing

