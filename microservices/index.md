* マイクロサービスとは、WebAPIなどのRPC（Remote Procedure Call）を通じて、小さいサービス同士をつないで連携し、一つのサービスを構成する手法のこと。
* 基本的な思想
   * サービスを孤高製する各要素を疎結合に構成して連携する
   * 各要素に適した技術を用いる
   * サービス感の会話はAPIなど決められた様式に従う
-> 大規模なサービスを分割して小さなコンポーネントにする設計（SOAなどの形でもともと存在していた）

* メリット
   * 障害発生時の影響を少なくし、分業して開発にあたることができる、リリースの速度が向上可能になる
   * 開発担当者の責任範囲を分割できること
   * 「API」と「疎結合なコミュニケーション」が自動化を可能にし、信頼性が向上する
* デメリット
   * 自分の管轄外のコンポーネントやプロダクトに対して無関心になりがちで、属人性も高くなる
   * 様々なマイクロサービスのバージョンの組み合わせ爆発が起こる

* コンポーネント単位で責任範囲が分割された世界でコミュニケーションをどうとるか
   * IDLを用いてAPIを提示する(例 Thrift)
      * IDLってなんだろう
   * テストコードをきちんと書く

* 分割と共有
   * 分割の単位をどう決めるか
      * いざ障害が発生した時に、止めて良いサービスとそうでないサービスを考えた上で設計する
      * 分割の最小単位を、ユーザーにとって動いてほしい単位の一つの1個にマイクロサービスがある状態にすると良い
      * ユーザーから見たら同じ機能だが、提供プラットフォームが違うものは分ける

   * 共有化したい部分はどこにあるかを明確にする
      * 例えばDBやストレージにアクセスするための特殊なビジネスロジックは1個のコンポーネントにまとめた方がメンテナンスがしやすく、再利用性が高まる

* マイクロサービスアーキテクチャ運用の注意点
   * Cascading Failure（ドミノ倒し）
      * いわゆるドミノ倒しのように、一つのコンポーネントの障害を引き金に複数の機能が連鎖して動かなくなってしまう状態
      * サーキットブレーカー（遮断器）が必要（機能Aが壊れた時にも機能Bが動き続けるような考慮）
      -> サービスの本質的な部分を使えるようにし、障害が起こっている部分へのアクセスを一時的に切り離す
      * 他にも多少データが古くても動いて問題ナイものならデータキャッシュし、ほしい応答が得られない時に代わりに応答するやり方もある
      * Draceful Degradation: サービス全体の品質を積極的に低下させることで、サービスの本当に大事な部分を守る
   * Cyclic Dependency（循環依存）
      * マイクロサービスが巡り巡って自分自身に依存、デッドロック発生
      * 同期的な処理を行う場合にCyclic Dependencyの一箇所で利そす不足や問題が発生すると全体の処理が止まってしまう
      * Cyclic Dependencyがるようなモジュールを全て再起動させる必要があるケースえどの順番で立ち上がればいいかわからないようなケース
      * 同期的な依存を非同期化することで解決、「機能Aが情報をキューに入れ、終わりにして次の処理に映る」（例 Apache Kafka）
   * リソース不足
      * 大量の呼び出しが発生した場合に、過負荷に陥らないような考慮が必要
      * Retry Strategy, Rate Limit & Throttling（= 流量制限）
      * 例えば、機能Aがあるユーザーから受け付けるリクエストは同時に3つまで、機能Bで10件の処理待ちが発生したらそれ以上は機能Aからの呼び出しを受け付けないといった要領
   * 全体像が把握できなくなってしまう
      * 「ボタンを押す」のようなアクションを起こしたあと、どのコンポーネントが呼び出されているかを可視化するようなツールが必要
      * 分散されたサービスナイのリクエストを可視化し、システムの挙動や性能を把握することを、分散トレーシングと呼ぶ
      * ZipkinやOpenTracing

# 設計パターン
## APIゲートウェイパターン
* 概要
   * Backends for Frontends（BFF）とも言う
   * バックエンドサービスを頻繁に呼び出す場合、多様なクライアント、デバイスによって提供するコンテンツが違う場合に向いている
   * Amazon API Gatewayが使える
* Amazon API Gateway
   * あらゆるスケールのセキュアなAPIを容易に、作成、発行、保守、モニタ可能なフルマネージドなサービス
# サーキットブレーカーパターン
* IstioとEnvoyProxyをAmazonEKSで利用

# コマンドクエリ責務分離（CQRS）パターン
* データを更新するコマンドと参照するクエリを分離することで、ユースケースに応じて個別にスケールできるようにする
* 
* コマンド側とクエリ側が結果整合性を許容する必要がある
# イベントソーシングパターン
* データストアを直
# コレオグラフィーパターン


# Istioとは
* マイクロサービスをセキュアにマネージメントするためのOSS。
* サービスメッシュ間の認証やモニタリング、L7での柔軟なロードバランシングが提供されている。

# Envoyとは
* サービスメッシュのイン/アウトバウンドの全てのトラフィックを管理するプロキシサーバー
* KubernetesではPodのサイドカーとしてデプロイする

# マイクロサービスの課題
## ServiceDiscovery
* 複数の小さなサービスが相互に連携するマイクロサービスにおいては、依存関係にあるサービスの接続情報の管理が課題
* DNSやロードバランサの設定変更は悪手

## 障害の分離
* サーキットブレーカーパターンによって障害のあったサービスへのアクセスを遮断することで大規模障害のリスクを減らす
* 各サービスの外部呼び出し側に実装しなければ行けないためコストが大きい

## 分散トレーシング
* 一つのリクエストが複数のサービスに跨がる事により、リクエスト全体の処理の流れを把握することが難しくなる
* レスポンスの悪化やエラーエラーの発生箇所を把握したり確認したりすることは難しい

## 認証・認可

=> Service Discovery、Fault Isolation、Observability、Securityなどの課題からアプリケーション開発者を解放し、開発者がアプリケーション開発に専念できるよう登場したのが「サービスメッシュ」という概念とソフトウェア

