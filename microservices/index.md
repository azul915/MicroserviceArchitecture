* マイクロサービスとは、WebAPIなどのRPC（Remote Procedure Call）を通じて、小さいサービス同士をつないで連携し、一つのサービスを構成する手法のこと。
* 基本的な思想
   * サービスを孤高製する各要素を疎結合に構成して連携する
   * 各要素に適した技術を用いる
   * サービス感の会話はAPIなど決められた様式に従う
-> 大規模なサービスを分割して小さなコンポーネントにする設計（SOAなどの形でもともと存在していた）

* メリット
   * 障害発生時の影響を少なくし、分業して開発にあたることができる、リリースの速度が向上可能になる
   * 開発担当者の責任範囲を分割できること
   * 「API」と「疎結合なコミュニケーション」が自動化を可能にし、信頼性が向上する
* デメリット
   * 自分の管轄外のコンポーネントやプロダクトに対して無関心になりがちで、属人性も高くなる
   * 様々なマイクロサービスのバージョンの組み合わせ爆発が起こる

* コンポーネント単位で責任範囲が分割された世界でコミュニケーションをどうとるか
   * IDLを用いてAPIを提示する(例 Thrift)
      * IDLってなんだろう
   * テストコードをきちんと書く

* 分割と共有
   * 分割の単位をどう決めるか
      * いざ障害が発生した時に、止めて良いサービスとそうでないサービスを考えた上で設計する
      * 分割の最小単位を、ユーザーにとって動いてほしい単位の一つの1個にマイクロサービスがある状態にすると良い
      * ユーザーから見たら同じ機能だが、提供プラットフォームが違うものは分ける

   * 共有化したい部分はどこにあるかを明確にする
      * 例えばDBやストレージにアクセスするための特殊なビジネスロジックは1個のコンポーネントにまとめた方がメンテナンスがしやすく、再利用性が高まる

* マイクロサービスアーキテクチャ運用の注意点
   * Cascading Failure（ドミノ倒し）
      * いわゆるドミノ倒しのように、一つのコンポーネントの障害を引き金に複数の機能が連鎖して動かなくなってしまう状態
      * サーキットブレーカー（遮断器）が必要（機能Aが壊れた時にも機能Bが動き続けるような考慮）
      -> サービスの本質的な部分を使えるようにし、障害が起こっている部分へのアクセスを一時的に切り離す
      * 他にも多少データが古くても動いて問題ナイものならデータキャッシュし、ほしい応答が得られない時に代わりに応答するやり方もある
      * Draceful Degradation: サービス全体の品質を積極的に低下させることで、サービスの本当に大事な部分を守る
   * Cyclic Dependency（循環依存）
      * マイクロサービスが巡り巡って自分自身に依存、デッドロック発生
      * 同期的な処理を行う場合にCyclic Dependencyの一箇所で利そす不足や問題が発生すると全体の処理が止まってしまう
      * Cyclic Dependencyがるようなモジュールを全て再起動させる必要があるケースえどの順番で立ち上がればいいかわからないようなケース
      * 同期的な依存を非同期化することで解決、「機能Aが情報をキューに入れ、終わりにして次の処理に映る」（例 Apache Kafka）
   * リソース不足
      * 大量の呼び出しが発生した場合に、過負荷に陥らないような考慮が必要
      * Retry Strategy, Rate Limit & Throttling（= 流量制限）
      * 例えば、機能Aがあるユーザーから受け付けるリクエストは同時に3つまで、機能Bで10件の処理待ちが発生したらそれ以上は機能Aからの呼び出しを受け付けないといった要領
   * 全体像が把握できなくなってしまう
      * 「ボタンを押す」のようなアクションを起こしたあと、どのコンポーネントが呼び出されているかを可視化するようなツールが必要
      * 分散されたサービスナイのリクエストを可視化し、システムの挙動や性能を把握することを、分散トレーシングと呼ぶ
      * ZipkinやOpenTracing

# 設計パターン
## APIゲートウェイパターン
* 概要
   * Backends for Frontends（BFF）とも言う
   * バックエンドサービスを頻繁に呼び出す場合、多様なクライアント、デバイスによって提供するコンテンツが違う場合に向いている
   * Amazon API Gatewayが使える
* Amazon API Gateway
   * あらゆるスケールのセキュアなAPIを容易に、作成、発行、保守、モニタ可能なフルマネージドなサービス
   * リクエスト/レスポンス データ変換とAPIモック
   * CloudFrontを通じたレイテンシの削除とDDoS保護
   * Swaggger/OpenAPIサポート
## サービスディスカバリ/サービスレジストリパターン
* 概要
   * `サービスレジストリ`は、個々のコンテナやインスタンスの起動時に、呼び出されるサービスがそのサービス自体の情報を保存
   * `サービスディスカバリ`は、動的に変更する関連するサービスのアドレスを取得して、接続先として情報を記録
* 実装例
   * Elastic Load Balancing
   * AWS Cloud Map
   * Amazon ECSのサービスディスカバリを利用
   * AWS AppMeshのサービスメッシュのサービスディスカバリ

## サーキットブレーカーパターン
* 概要
   * マイクロサービス間の呼び出しを規制し、グレースフルな機能低下を実現
   * サービスが相手サービスの呼び出しに通常より長い時間がかかった場合やエラーが返された場合、サーキットブレーカーがインシデント数をカウント
   * カウントが設定された制限を超えるとオープン状態に移行、オープン状態になると、サーキットブレーカーは呼び出し元に即座にエラーを返却
   * 一定時間が経過、またはヘルスチェックによって相手サービスが復活すると、サーキットブレーカーはクローズ状態に戻り、相手サービスへの呼出も平常時の状態に戻る

* 実装例
   * IstioとEnvoyProxyをAmazonEKSで利用

## コマンドクエリ責務分離（CQRS）パターン
* 概要
   * データを更新するコマンドと参照するクエリを分離することで、ユースケースに応じて個別にスケールできるようにする
   * データソースを分離することで、異なるデータ構造を摂ることも可能となり、クエリ側はクエリで返すDTOにあわせた形のスキーマとすることでオブジェクト関係マッピングのオーバーーヘッドを軽減することも可能になる
   * コマンド側とクエリ側が結果整合性を許容する必要がある
* 実装例
   * AmazonKinesisDataStreamsとAWSLambdaを利用
   * Amazon DynamoDB StreamsとAWSLambdaを利用

## イベントソーシングパターン
* 概要
   * データストアを直接更新する代わりにビジネスロジックに重要なイベントを耐久性のあるイベントログに追加
   * 全ての更新はアトミック
* 実装例
   * AmazonKinesisDataStreamとAWSLambda

## コレオグラフィーパターン
* 概要
   * 必要な全ての情報を含んだ最初のイベントを1つのメッセージに保存して、最初のトランザクションを完了
   * 他のサービスがそのメッセージを非同期的に取得し、それぞれのタスクを完了させる
   * サービスが疎結合になり直接互いに影響を与えない
   * メッセージの保存と取得が非同期の関係になり、スケーラビリティと信頼性が向上
* 実装例
   * AmazonSNS、AmazonSQS、AWSLambda
## 集約ログパターン
* 概要
   * ログデータ集約、トレース、モニタリング
* 実装例
   * Amazon CloudWatchLogs AWS X-Ray

# マイクロサービスの課題
## ServiceDiscovery
* 複数の小さなサービスが相互に連携するマイクロサービスにおいては、依存関係にあるサービスの接続情報の管理が課題
* DNSやロードバランサの設定変更は悪手

## 障害の分離
* サーキットブレーカーパターンによって障害のあったサービスへのアクセスを遮断することで大規模障害のリスクを減らす
* 各サービスの外部呼び出し側に実装しなければ行けないためコストが大きい

## 分散トレーシング
* 一つのリクエストが複数のサービスに跨がる事により、リクエスト全体の処理の流れを把握することが難しくなる
* レスポンスの悪化やエラーエラーの発生箇所を把握したり確認したりすることは難しい

## 認証・認可

# サービスメッシュの登場
* Service Discovery、Fault Isolation、Observability、Securityなどの課題からアプリケーション開発者を解放し、開発者がアプリケーション開発に専念できるよう登場したのが「サービスメッシュ」という概念とソフトウェア
* 全てのサービスに対して「サイドカープロキシ」を用意し、サービス間のコミュニケーションを全てサイドカープロキシ経由とすることで、課題解決を図る

# サービスメッシュのためのソフトウェア

## Istio
* マイクロサービスをセキュアにマネージメントするためのOSS。
* サービスメッシュ間の認証やモニタリング、L7での柔軟なロードバランシングが提供されている。
* アーキテクチャは大きく「Data Plane」と「Control Plane」の2つに分けられる
### Data Plane
* プロキシによるマイクロサービス間の通信を管理
* Istio用に拡張された「Envoy」をサイドカープロキシとしてKubernetesのPod内にデプロイしている
### Control Plane
* Mixer: サイドカープロキシ（Envoy）から各サービスのデータを収集し、その情報を元にアクセスコントロールを行うコンポーネント
* Pilot: サイドカープロキシ（Envoy）のサービスディスカバリやトラフィック管理を担当するコンポーネント。例えばA/Bテスト・カナリアリリース実現や、タイムアウト・リトライ・サーキットブレーカーなどの手法を用いてFaultIsolation（障害の分離）の問題を解決することができる
* Citadal(Istio-Auth): サービス感認証とエンドユーザー認証を実現するコンポーネント

## Envoy
* サービスメッシュのイン/アウトバウンドの全てのトラフィックを管理するプロキシサーバー
* KubernetesではPodのサイドカーとしてデプロイする
* サイドカープロキシとしてデプロイされ、各サービスに対してアプリケーションの改修なく、以下のような機能を付加できる
   * サービスディスカバリ
   * 負荷分散
   * TLS終端
   * HTTP/2とgPRCのプロキシ
   * サーキットブレーカー
   * ヘルスチェック
   * トラフィックの分割（A/Bテスト）
   * Fault Injection（フォールト・インジェクション）
   * メトリクス取得


# 参考
* https://aws.amazon.com/jp/blogs/news/webinar-bb-aws-microservice-architecture-2020/
